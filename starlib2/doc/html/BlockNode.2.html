<html><head><TITLE>BlockNode</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  BlockNode : public <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>, private <!1><A HREF="ASTnodeWithPosBits.html">ASTnodeWithPosBits</A> </H2><BLOCKQUOTE>
A single block in the file - this can be either a
data block or a global block - they are both handled
the same way
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CASTnode,MASTnode.2.html,CBlockNode,MBlockNode.2.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="up">
</APPLET>
<hr>

<DL>
<TABLE BORDER>
<DT><h3>Public Fields</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.36.22"> <IMG BORDER=0 SRC=icon1.gif></A> protected  :  <!1><A HREF="DataListNode.2.html">DataListNode</A>* </TD><TD><B>myDataList</B> <br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.23"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="HeadingNode.2.html">HeadingNode</A>* </TD><TD><B>myHeading</B> <br>
<I></I>
</TD></TR></TABLE><TABLE BORDER>
<DT><h3>Public Methods</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.36.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A> </TD><TD><B>AddSaveFrame</B> (const string & name)<br>
<I><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A> </TD><TD><B>AddSaveFrameDataItem</B> ( const string & name, const string & value, <!2><A HREF="DataValueNode.2.html#DOC.31.1">DataValueNode::ValType</A> type)<br>
<I><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.7"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A> </TD><TD><B>AddSaveFrameLoop</B> ()<br>
<I><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A> </TD><TD><B>AddSaveFrameLoopDataName</B> (const string & name)<br>
<I><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.9"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A> </TD><TD><B>AddSaveFrameLoopDataValue</B> ( const string & value, <!2><A HREF="DataValueNode.2.html#DOC.31.1">DataValueNode::ValType</A> type )<br>
<I><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.4"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>AddSaveFrameToDataBlock</B> (<!1><A HREF="DataNode.html">DataNode</A>* newNode)<br>
<I><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.18"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="ASTlist.html">ASTlist</A> <<!1><A HREF="DataNode.html">DataNode</A>*> * </TD><TD><B>GiveMyDataList</B> (void)<br>
<I>Return the list of data nodes that reside inside this block node:
This list is a vector and can be used like the STL vector to
add/delete/iterate over the the things in the block</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.17"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool </TD><TD><B>isOfType</B> ( <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTtype</A> T )<br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.14"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int </TD><TD><B>myLongestStr</B> ( void )<br>
<I>
Returns the length of the longest string in this object</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.19"> <IMG BORDER=0 SRC=icon1.gif></A> string </TD><TD><B>myName</B> () const <br>
<I>Return the label of this block node, eg "data_foo" :</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.16"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTnode::ASTtype</A> </TD><TD><B>myType</B> (void)<br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.3"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>RemoveSaveFrame</B> (string saveframeName)<br>
<I><em>DEPRECIATED - use STL vector erase() on the list returned by
GiveMyDataList instead</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.20"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="DataNode.html">DataNode</A>* </TD><TD><B>ReturnDataBlockDataNode</B> (string saveframeName)<br>
<I>
Return the data node matching the name given
(A save frame, data item, or loop)</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.10"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="List.html">List</A> <<!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*> * </TD><TD><B>searchByTag</B> ( string &searchFor)<br>
<I>
Given a tag name, find the AST object it resides in</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.12"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="List.html">List</A> <<!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*> * </TD><TD><B>searchByTagValue</B> ( string &tag, string &value )<br>
<I>
Given a tag name and a value, find the AST object that that
particular tag and value pair resides in</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.11"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="List.html">List</A> <<!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*> * </TD><TD><B>searchForType</B> ( <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTtype</A> type, int delim = -1 )<br>
<I>
This method returns a list of all the nodes of the given type
that are inside this node, or children of this node, or children
of children of this node, etc all the way down to the leaf nodes</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.13"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool </TD><TD><B>unlinkChild</B> ( <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A> *child )<br>
<I>
unlinks the given ASTnode from this ASTnode, assuming that
the given ASTnode is a child of this ASTnode</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.21"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>Unparse</B> (int indent)<br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.15"> <IMG BORDER=0 SRC=icon1.gif></A> virtual </TD><TD><B>~BlockNode</B> ()<br>
<I> Destructor.  This will destruct everything inside the block as well.</I>
</TD></TR></TABLE><TABLE BORDER>
<DT><h3>Public</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.36.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B></B> <br>
<I></I>

<TABLE BORDER>
<TR><TD VALIGN=top><A HREF="#DOC.36.2.2"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  string& </TD><TD><B>getPreComment</B> ( void )<br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.2.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void </TD><TD><B>setPreComment</B> ( const string &cmt )<br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.2.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B></B> <br>
<I>These functions are used to give some nodes in the
AST tree the ability to remember a comment to be
pasted into the file in front of that node</I>
</TD></TR>
</TABLE>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B></B> <br>
<I></I>

<TABLE BORDER>
<TR><TD VALIGN=top><A HREF="#DOC.36.1.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B></B> <br>
<I><b>Constructors:</b> </I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.1.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BlockNode</B> (<!1><A HREF="HeadingNode.2.html">HeadingNode</A> *h, <!1><A HREF="DataListNode.2.html">DataListNode</A> *n)<br>
<I></I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.1.3"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BlockNode</B> (const string & name)<br>
<I> give the name to call the block.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.1.4"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BlockNode</B> ( <!2><A HREF="BlockNode.2.html#DOC.36.1.5">BlockNode</A> &n )<br>
<I> deep copy constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.36.1.5"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BlockNode</B> ( bool link, <!2><A HREF="BlockNode.2.html#DOC.36.1.5">BlockNode</A> &n )<br>
<I> for more details on parallel copies.</I>
</TD></TR>
</TABLE>
</TD></TR></TABLE></DL>
<hr><H3>Inherited from <A HREF="ASTnode.2.html">ASTnode:</A></h3>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><IMG SRC=icon2.gif>  enum  <B>ASTtype</B>

<DL>
<DT><A HREF="#DOC.81.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>ASTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>BLOCKNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATABLOCKNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATAFILENODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATAHEADINGNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.6"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATAITEMNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.7"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATALISTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.8"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATALOOPNAMELISTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.9"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATALOOPDEFLISTNODE</B> </B>
 <DD><I> <em>DEPRECIATED</em> - Do not use:</I>
<DT><A HREF="#DOC.81.1.10"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATALOOPNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.11"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATALOOPVALLISTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.12"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATANAMENODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.13"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATANODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.14"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DATAVALUENODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.15"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GLOBALBLOCKNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.16"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GLOBALHEADINGNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.17"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>HEADINGNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.18"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>LOOPROWNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.19"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>ITERNODE</B> </B>
 <DD><I> <em>DEPRECIATED</em> - Do not use:</I>
<DT><A HREF="#DOC.81.1.20"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>LOOPNAMELISTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.21"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>LOOPDEFLISTNODE</B> </B>
 <DD><I> <em>DEPRECIATED</em> - Do not use:</I>
<DT><A HREF="#DOC.81.1.22"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>LOOPTABLENODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.23"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>LOOPITER</B> </B>
 <DD><I> <em>DEPRECIATED</em> - Do not use:</I>
<DT><A HREF="#DOC.81.1.24"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>LOOPVALLISTNODE</B> </B>
 <DD><I> <em>DEPRECIATED</em> - Do not use:</I>
<DT><A HREF="#DOC.81.1.25"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SAVEFRAMELISTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.26"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SAVEFRAMENODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.27"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SAVEHEADINGNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.28"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>STARLISTNODE</B> </B>
 <DD><I></I>
<DT><A HREF="#DOC.81.1.29"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>STARFILENODE</B> </B>
 <DD><I></I>

</DL>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> virtual  void  <B>copyFrom</B>( const <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A> &copyFromMe )
<DT><IMG SRC=icon2.gif> virtual  <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*  <B>myParent</B>(void)
<DT><IMG SRC=icon2.gif> bool  <B>NotVirtualIsOfType</B>( <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTtype</A> T )
<DT><IMG SRC=icon2.gif> virtual  bool  <B>removeChild</B>( <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A> *child )
<DT><IMG SRC=icon2.gif> virtual  bool  <B>removeMe</B>( void )
<DT><IMG SRC=icon2.gif> virtual  void  <B>setParent</B>( <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A> *p )
<DT><IMG SRC=icon2.gif> virtual  bool  <B>unlinkMe</B>( void )
</DL></DL>
<hr><H3>Inherited from <A HREF="ASTnodeWithPosBits.html">ASTnodeWithPosBits:</A></h3>

<DL>
</DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>
A single block in the file - this can be either a
data block or a global block - they are both handled
the same way

</BLOCKQUOTE>
<DL>

<A NAME="">
<A NAME ="DOC.36.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DL></DL><P><DL>

<A NAME="">
<A NAME ="DOC.36.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DD><b>Constructors:</b> 
<DL></DL><P>
<A NAME="BlockNode">
<A NAME ="DOC.36.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BlockNode(<!1><A HREF="HeadingNode.2.html">HeadingNode</A> *h, <!1><A HREF="DataListNode.2.html">DataListNode</A> *n)</B></TT>
<DL></DL><P>
<A NAME="BlockNode">
<A NAME ="DOC.36.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BlockNode(const string & name)</B></TT>
<DD> give the name to call the block.
<DL></DL><P>
<A NAME="BlockNode">
<A NAME ="DOC.36.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BlockNode( <!2><A HREF="BlockNode.2.html#DOC.36.1.5">BlockNode</A> &n )</B></TT>
<DD> deep copy constructor
<DL></DL><P>
<A NAME="BlockNode">
<A NAME ="DOC.36.1.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BlockNode( bool link, <!2><A HREF="BlockNode.2.html#DOC.36.1.5">BlockNode</A> &n )</B></TT>
<DD> for more details on parallel copies.
<DL></DL><P></DL>

<A NAME="~BlockNode">
<A NAME ="DOC.36.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~BlockNode()</B></TT>
<DD> Destructor.  This will destruct everything inside the block as well.
<DL></DL><P>
<A NAME="myType">
<A NAME ="DOC.36.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTnode::ASTtype</A>  myType(void)</B></TT>
<DL></DL><P>
<A NAME="isOfType">
<A NAME ="DOC.36.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool  isOfType( <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTtype</A> T )</B></TT>
<DL></DL><P>
<A NAME="">
<A NAME ="DOC.36.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DL></DL><P><DL>

<A NAME="getPreComment">
<A NAME ="DOC.36.2.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  string&  getPreComment( void )</B></TT>
<DL></DL><P>
<A NAME="setPreComment">
<A NAME ="DOC.36.2.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setPreComment( const string &cmt )</B></TT>
<DL></DL><P>
<A NAME="">
<A NAME ="DOC.36.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  </B></TT>
<DD>These functions are used to give some nodes in the
AST tree the ability to remember a comment to be
pasted into the file in front of that node.  This
is useful if you want to insert header comments of
some sort into the output produced by Unparse().
As of this writing, no provisions are being made
to handle the parsing of comments from the original
file and storing them via these functions.  The
grammar to do that would be rather convoluted.
These functions are only intended to be used by programs
insterting their own comments after the file has
been read.
<p>
In the interest of saving memory, the preComment ability
only exists at the level of saveframenodes and blocknodes.
If you attempt to use these functions at other levels,
nothing will happen (the comment will always be empty).
<p>
The string must contain the comment characters embedded
inside, like so: "# this is a\n# multiline comment.",
not like this: "this is a\nmultiline comment."  This is
so that the caller is allowed to have the comment contain
blank lines like this:
<pre>
# This is an example comment.

# The comment has some blank

# lines in it.
</pre>
If the Unparse() function were designed to insert the comment
characters (#) itself, then such a comment block would be impossible
to create.
<p>
Note that the comment lines are not syntax-checked in any way, so
using these functions it is entirely possible to create invalid
STAR files, since these "comments" can really be strings with
anything at all in them - so be careful.
<p>
To get rid of the preComment if you change your mind, set it to
a zero-length string with setPreComment().
<DL></DL><P></DL>

<A NAME="GiveMyDataList">
<A NAME ="DOC.36.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="ASTlist.html">ASTlist</A> <<!1><A HREF="DataNode.html">DataNode</A>*> *  GiveMyDataList(void)</B></TT>
<DD>Return the list of data nodes that reside inside this block node:
This list is a vector and can be used like the STL vector to
add/delete/iterate over the the things in the block
<DL></DL><P>
<A NAME="myName">
<A NAME ="DOC.36.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> string  myName() const </B></TT>
<DD>Return the label of this block node, eg "data_foo" :
<DL></DL><P>
<A NAME="ReturnDataBlockDataNode">
<A NAME ="DOC.36.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="DataNode.html">DataNode</A>*  ReturnDataBlockDataNode(string saveframeName)</B></TT>
<DD>
Return the data node matching the name given
(A save frame, data item, or loop)
<DL></DL><P>
<A NAME="RemoveSaveFrame">
<A NAME ="DOC.36.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  RemoveSaveFrame(string saveframeName)</B></TT>
<DD><em>DEPRECIATED - use STL vector erase() on the list returned by
GiveMyDataList instead.</em><br>
Remove the data item matching the name given (usually
a save frame).

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="AddSaveFrameToDataBlock">
<A NAME ="DOC.36.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  AddSaveFrameToDataBlock(<!1><A HREF="DataNode.html">DataNode</A>* newNode)</B></TT>
<DD><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead.</em><br>
Attach the given data node (usually a save frame) to the
AST.  Note that it just makes a link to the object, not a
copy.  Do not delete the object after calling this.

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="Unparse">
<A NAME ="DOC.36.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  Unparse(int indent)</B></TT>
<DL></DL><P>
<A NAME="AddSaveFrame">
<A NAME ="DOC.36.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A>  AddSaveFrame(const string & name)</B></TT>
<DD><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead.</em><br>
Add an empty save frame to the end of the block, using the name
given:

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="AddSaveFrameDataItem">
<A NAME ="DOC.36.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A>  AddSaveFrameDataItem( const string & name, const string & value, <!2><A HREF="DataValueNode.2.html#DOC.31.1">DataValueNode::ValType</A> type)</B></TT>
<DD><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead.</em><br>
Add a new item (tag/value pair) to the block in the last saveframe
of he block.  If the last thing in the block is not a save frame,
returns ERROR

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="AddSaveFrameLoop">
<A NAME ="DOC.36.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A>  AddSaveFrameLoop()</B></TT>
<DD><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead.</em><br>
Add a new empty loop to the last saveframe in the block.  Returns
ERROR if the last thing in the block is not a save frame.  Note
that no name is given, because the name of a loop is derived
from its first tag name - and an empty loop has no first tag.

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="AddSaveFrameLoopDataName">
<A NAME ="DOC.36.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A>  AddSaveFrameLoopDataName(const string & name)</B></TT>
<DD><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead.</em><br>
Add a tag name to the last loop of the last save frame in the
block.  Returns ERROR if the last thing in the block is not
a save frame, or if the last thing in the save frame is not a loop.

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="AddSaveFrameLoopDataValue">
<A NAME ="DOC.36.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="StarFileNode.3.html#DOC.53.1">StarFileNode::Status</A>  AddSaveFrameLoopDataValue( const string & value, <!2><A HREF="DataValueNode.2.html#DOC.31.1">DataValueNode::ValType</A> type )</B></TT>
<DD><em>DEPRECIATED - use STL vector insert() on the list returned
by GiveMyDataList instead.</em><br>
Add a value to the last loop of the last save frame in the
block.  Returns ERROR if the last thing in the block is not
a save frame, or if the last thing in the save frame is not a loop.

<DL><DT><B>See Also:</B><DD><!2><A HREF="BlockNode.2.html#DOC.36.18">GiveMyDataList</A><br></DL><P>
<A NAME="searchByTag">
<A NAME ="DOC.36.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="List.html">List</A> <<!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*> *  searchByTag( string &searchFor)</B></TT>
<DD>
Given a tag name, find the AST object it resides in.  It returns
a pointer to the lowest level AST object that the tag resides in.
The caller of this function needs to use the isOfType() and/or
myType() methods to determine what type to cst the object.
Returns a NULL if nothing was found.
<P>
This search is case-insensitive.  The names of things, according
to the STAR specification, are supposed to be case-insensitive.
This is being applied not only to tag names but also to
saveframe names and datablock names.
<P>
WARNING: The list returned is allocated in heap space.  It is
the caller's responsibility to delete the list after it is no
longer needed.

<DL><DT><B>Parameters:</B><DD><B>searchFor</B> -  Look for this string as the tag name.<br></DL><P>
<A NAME="searchForType">
<A NAME ="DOC.36.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="List.html">List</A> <<!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*> *  searchForType( <!2><A HREF="ASTnode.2.html#DOC.81.1">ASTtype</A> type, int delim = -1 )</B></TT>
<DD>
This method returns a list of all the nodes of the given type
that are inside this node, or children of this node, or children
of children of this node, etc all the way down to the leaf nodes.


<DL><DT><B>Parameters:</B><DD><B>type</B> -  type to search for
<br><B>delim</B> -  the delimiter type if searching for a DataValueNode.  The
default is "dont-care".<br></DL><P>
<A NAME="searchByTagValue">
<A NAME ="DOC.36.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="List.html">List</A> <<!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A>*> *  searchByTagValue( string &tag, string &value )</B></TT>
<DD>
Given a tag name and a value, find the AST object that that
particular tag and value pair resides in.  This is like
performing an SQL search: WHERE tag = value.

<P>
This search is case-insensitive.  The names of things, according
to the STAR specification, are supposed to be case-insensitive.
This is being applied not only to tag names but also to
saveframe names and datablock names.
<P>
(However, the values are case-sensitive.  A search for a
tag of <TT>_t1</TT> is identical to a search for a tag of <TT>_T1</TT>,
but a search for a <b>value</b> of "V1" is different from a search for
a value of "v1".)
<P>
WARNING: The list returned is allocated in heap space.  It is
the caller's responsibility to delete the list after it is no
longer needed.

<DL><DT><B>Parameters:</B><DD><B>tag</B> -  Look for this tag name...
<br><B>value</B> -  Where it has this value<br></DL><P>
<A NAME="unlinkChild">
<A NAME ="DOC.36.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool  unlinkChild( <!2><A HREF="ASTnode.2.html#DOC.81.21">ASTnode</A> *child )</B></TT>
<DD>
unlinks the given ASTnode from this ASTnode, assuming that
the given ASTnode is a child of this ASTnode.  Does NOT
call the destructor of the child node!! Use this function to
remove the child from this ASTnode but not free it's space.
RETURNS: true if the child was unlinked.  false if the given
ASTnode was not even in this class anywhere, and
therefore nothing was done.
This function MUST be overridden for each subclass of ASTnode.
<DL></DL><P>
<A NAME="myDataList">
<A NAME ="DOC.36.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> protected  :  <!1><A HREF="DataListNode.2.html">DataListNode</A>*  myDataList</B></TT>
<DL></DL><P>
<A NAME="myHeading">
<A NAME ="DOC.36.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="HeadingNode.2.html">HeadingNode</A>*  myHeading</B></TT>
<DL></DL><P>
<A NAME="myLongestStr">
<A NAME ="DOC.36.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int  myLongestStr( void )</B></TT>
<DD>
Returns the length of the longest string in this object.
Used by Unparse() at various levels of the AST tree.
In this case it just returns the longest of the heading node or
the data list node:
<DL></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<I><FONT SIZE=-1>Starlib is a creation of BioMagResBank:
bmrb.wisc.edu</FONT></I>
<IMG SRC="starlib_banner.gif" ALT="starlib banner">
<BR>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
