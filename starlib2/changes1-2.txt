Some Changes between starlib and starlib2, that will affect
             programs using starlib:
------------------------------------------------------------

To reduce the amount of memory being eaten by starlib, the
data values that are in loops must be compacted down to 
small values rather than the large DataValueNodes that
contain them currently.  Consider the following:

   Currently, a DataValueNode contains:

     - A C++ string type to contain the value
         (8 bytes made of: a 4-byte char ptr, and a 4 byte int for length).
     - A bitfield containing sundry status flags (2 bytes).
     - A parent pointer. (4 bytes)
     - A peer pointer. (4 bytes)
     - A precomment string.  (4 bytes)
   Total bytes of overhead: 22
   22 bytes may sound efficient, but remember that this is to store a
   value that might be as short as only 2 characters in the text file,
   for a total blouwp factor of 11 times.  This causes files containing
   large loops of 6 megabytes to take at least 66 megabytes of RAM to
   store in the starlib.  This is bad because files with as much as 10
   meg of data will soon become common, and some applications have more
   than one copy of the starlib tree in memory at once, so this blowup
   factor makes those files unworkable in starlib.

   To solve the problem, the above overhead needs to be removed for
   the values that are inside of loops.

   Something to accomplish this was done in the Java version of the
   starlib by encoding the data for a LoopRow inside a single
   string, and then rendering the values in that string into
   DataValueNodes generated as needed.  This worked great, except for
   one large problem: such a strategy depends on the existance of
   garbage collection in Java.  It was acceptable practice to generate
   fake DataValueNodes and give them to the calling code because we
   knew they would eventually "go away" on their own.

   This same assurance does not exist in C++, and generating our
   own garbage collection scheme will be problematic, since the
   language CANNOT tell us when a caller is done using a handle
   we gave him.  The solution I propose, then, is as follows:

   1 - We store a Loop Row as a simple string, with all values
   in the one string.
   2 - When someone tries to access a DataValueNode that is in
   the row, we do the following:
      A - Has a DataValueNode already been generated for this
      value?  If so, then refer to it.
      B - Else, generate a new DataValueNode from the data in the
      row's string, and put it into the DVNcache, then refer to it.
   3 - There will exist a DVNcache (Data Value Node cache) that
   contains nodes that have been previously generated by 2.B above.
   values in this cache might disagree with what is in the string,
   and if they do, then the values in the cache take precidence over
   the values in the string.
   4 - To make this work, two low-level primitives need to be 
   implemented - DVNcache.generate() and DVNcache.release().
   The generate function will perform what was said in point 2
   above (refer to the existing item in cache, or put it in the
   cache if it isn't there yet.)  The DVNcache.release() method
   will copy the value back out to the row's string if it is 
   marked as "dirty", and then remove it from the DVNcache.
   6 - When a LoopRowNode is destructed, it will first clean up
   after itself by releasing anything it may have had in the
   LoopTableNode's DVNcache.
   7 - The calling program can and should explicitly call the
   LoopRowNode or LoopRowTable's cache releaser when it knows it
   is done using the values there.  Otherwise the values will
   live until the entire object is descructed.
   
   
The DVNcache routines: (Not a separate class, part of DataLoopNode).

    This set of routines will need to be able to perform the following actions:

      1 - Lookup to see if the requested DataValueNode is already in
      cache, given a row and column number.
      2 - generate a DataValueNode into the cache given its row and
      column.
      3 - release a DataValueNode from the cache given its row and column,
      or its pointer.  This routine includes writing out the value back
      into the real table in the loop.


